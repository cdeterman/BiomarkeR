###################################
### Simulated Metabolomics Data ###
###################################

# currently a problem when trying to induce correlations
# Error in t(t(U[, (start + 1):end]) * pm) : 
#   dims [product 400] do not match the length of object [0]

plus_minus <- function(beta){
  inv <-rbinom(beta,1,0.5)
  inv <-ifelse(inv==0,-1,1)
  return(inv)
}

ind_corr <- function(group_size, start, end){
  pm <- plus_minus(group_size-1)
  
  # take first column of block
  f <- U[,start]
  #copy to each subsequent column
  #second <- start+1
  U[,(start+1):end] <- f
  U[,(start+1):end]
  #change sign
  finish <- t(t(U[,(start+1):end])*pm)  
  return(finish)
}

## Create a noise matrix
noise.matrix <- function(matrix, k){
  nvar <- ncol(matrix)
  nsamp <- nrow(matrix)
  
  # for each variable j a value wj is obtained from a random generated uniform distribution from 0 to k
  wj <- runif(nvar, max=k, min=0)
  
  # wij - vector of uniform random numbers -Wj < wij < Wj
  # add wij to each element of matrix B
  noise <- matrix(0, nrow=nsamp, ncol=nvar)
  for (i in 1:ncol(noise)){
    wij <- runif(nsamp, min=-wj[i], max=wj[i])
    noise[,i] <- wij}
  
  return(noise)
}

#normal distribution
# can define mean and st.dev
#?(rnorm)
#rnorm(10)

#uniform distribution
# can define min and max
#?(runif)
#runif(10)

## 1st Matrix - Random (Independent)
#create matrix - rows = samples, columns = variables
  # generate random numbers of defined standard deviation and range

nvar <- 300
nsamp <- 200
I <- nsamp/2
classes <- factor(sort(rep(c("A","B"), I)))

create.random.matrix <-
  function(nvar,    # number of variables
           nsamp    # number of samples
           )
    {
    ## Random numbers matrix
    # columns mean=0, sd=1
    R <- replicate(nvar, rnorm(nsamp, mean=0, sd=1))
    
    
    ### Perturb Normal Distribution
    # Random uniform numbers matrix
    # columns max=0.2, min=-0.2
    N <- replicate(nvar, runif(nsamp, max=0.2, min=-0.2))
    
    # Null matrix w/o any correlations
    U <- R + N
    U
  }

## 2nd Matrix - Pseudo Random (Non-independent)
# take a randomly generated matrix and induce correlations
create.corr.matrix <-
  function(U,     # Randomly generated matrix from create.random.matrix
           k=4    # level of correlation, higher = less correlation
           )
    {
    
    # generate block size (groups of variables to correlate)
    # discrete uniform distribution, 2>beta>5 - original (more appropriate for MS?)
    # set beta -> 1>x>5 to reflect that some variables likely independent with less dimensions in NMR
    beta <- sample(2:5, size=nvar-1, replace=T)
    #beta
    
    
    # loop through each block
    for (i in 1:length(beta)){ 
      if (i == 1){
        start <- 1
        end <- start + beta[i] - 1
        
        U[,(start+1):end] <- ind_corr(beta[i], start, end)
      }else{
        start <- end + 1
        
        if(start > nvar){
          start <- nvar
          end <- nvar
          cat('solo last variable')
          break
        }
        
        end <- end + beta[i]
        
        if(end > nvar){
          end <- nvar
          is_group <- end - start
          if (is_group > 1){
            U[,(start+1):end] <- ind_corr(is_group, start, end)
          }
          
          #print(head(U[,start:end]))
          #print(end)
          #print(i)
          #cat('not enough remaining variables\n')
          break
        }
        
        if (beta[i] != 1){
          U[,(start+1):end] <- ind_corr(beta[i], start, end)  
        }  
        B <- U
      }
    }
    
    
    ## Create a noise matrix to perturb distributions
    W <- noise.matrix(B, k)
    B <- B + W
    
    # randomize order of columns to make blocks no longer obvious
    rand <- sample(nsamp)
    V <- B[rand,]
    V
  }

## 3rd Matrix - Pseudo Random + Biomarkers (non-independent + defined changes)
#create matrix - rows = samples, columns = variables
create.disc.matrix <-
  function(V,         # Correlated Matrix generated by create.corr.matrix
           D = 20,    # number of discriminatory varables
           l = 1.5    # level of discrimination, higher = greater the separation
           )
  {
    nc <- ncol(V)
    d <- sample(nc, size = D, replace=F)
    Z <- V[,d]
    
    
    # get range of discriminatory ability (as is typical in real data)
    di <- runif(D, min=-l, max=l)
    
    # add di to first group, subtract from second to induce discrimination
    for(i in 1:D){
      Z[1:I,i] <- Z[1:I,i]+di[i]
      Z[(1+I):nsamp,i] <- Z[(1+I):nsamp,i]-di[i] 
    }
    
    # add newly discriminated variables back to matrix V to make matrix S
    S <- V
    S[,d] <- Z
    
    ## Create a noise matrix to perturb distributions again
    W <- noise.matrix(S, k)
    Y <- S + W
    Y
  }




# histograms of correlation coefficients

# function to determine max correlation
# must be the second highest because always 1 for correlation with self
# therefore remove max in each column and return new max
f4 <- function (x)
  {
  apply(x, 2, function(column) max(column[-which.max(column)]))
}

hist(f4(abs(cor(U))))
hist(f4(abs(cor(B))))
hist(f4(abs(cor(Y))))

